# 数据结构 data struct
* 链表
* 二叉树
    * 序列化和反序列化:判断两颗树是否相等
    * 还原树:需要先序遍历和中序遍历,至少2种
    * 最近公共祖先
    
* 完全二叉树
    * 统计节点个数时结合二叉树和满二叉树的算法，时间复杂度是O(lgn * lgn)
    
* 二叉搜索树(BST)
    * 中序遍历是升序的
    * 判断BST是否合法时，判断每个节点的最大值和最小值，增加参数的形式
    * void BST(TreeNode root, int target) {
      if (root.val == target)
      // 找到目标，做点什么
      if (root.val < target)
      BST(root.right, target);
      if (root.val > target)
      BST(root.left, target);
      }
    * 二叉搜索树有多少种形态，用区间逼近的方式[1, n]
    
* 平衡二叉树 @todo
    * 红黑树

* 图
    * 实现方式
        * 邻接表：存储空间小
        * 邻接矩阵：可以直接判断2个点是否相邻
    * 形式
        * 加权有向图
        * 无向图
    * 题目
        * 二分图判定
        * 环检测
    
* Union-Find算法：解决图的动态连通性问题
    * 特点：自反性、传递性、对称性
    * 适时增加虚拟节点，想办法让元素分门别类，建立动态连通关系
    * 案例：
        判断合法等式（多个等式或不等式是否成立）
        连通性问题
      
* LRU & LRU  linkList & hash

* 数据流求中位数。使用优先队列

* 朋友圈时间线功能。合并K个有序列表  使用优先级队列保存头节点

* 单调栈:处理问题 next greater number
  * 倒序插入栈
  * 环形数组一般采用取余操作，或者2倍当前的数据
    
* 单调队列: 解决滑动窗口问题，窗口中少一个元素，每次加入元素时更新队列

* 二叉堆: 完全二叉树，存储在数组中, array[0]空置， 
  则parent=node/2, left=node*2, right=node*2 + 1
  * 实现优先级队列

